---
layout: post
title: "Git workflows - GitHub flow"
categories: [git]
comments: true
---

브랜치는 어떻게 운영하는 것이 좋을까? 널리 알려진 Git Branching Model들에 대하여 알아 보자. [1편 - GitHub flow]

<!--more-->

## Git 브랜칭 전략

대표적인 브랜칭 전략에는 **Git-flow**, **GitHub-flow**와 **Gitlab-flow**가 있는데 오늘은 GitHub flow에 대하여 먼저 알아보도록 할 것이다.

[Scott Chacon의 포스팅](http://scottchacon.com/2011/08/31/github-flow.html){:target="\_blank"}에 따르면, GitHub flow가 고안된 가장 큰 이유 중 하나는 그들이 항상 "배포"하기 때문이라고 한다. 웹 애플리케이션과 같은 경우에선 일반적으로 지속적인 배포가 제공되는 형태로, git-flow 모델이 릴리스 중심으로 설계된 것에 반해 하루에도 여러 번 배포하기 때문에 이러한 활동을 실제로 "릴리스"라 칭하기엔 어렵다.

GitHub flow는 배포가 정기적으로 이루어 지는 팀과 프로젝트를 지원하는 가벼운, 브랜치 기반의 전략이라고 할 수 있다.

<br><br>

## 핵심 사항

GitHub flow의 핵심 사항은 다음과 같다:

- `master` 브랜치의 모든 것은 배포가 가능한 상태이다.
- 새로운 작업을 위해서, `master` 브랜치에서 설명하는 이름을 가진 브랜치를 만든다. (ex. `new-oauth2-scopes`)
- 로컬 브랜치에서 정기적으로 서버의 동일 브랜치명으로 작업 사항을 푸시하여 커밋하도록 한다.
- 피드백이나 도움이 필요하거나 작업한 브랜치를 병합할 준비가 되었다면 pull request를 연다.
- 다른 사용자가 기능에 대해 검토하고 종료하면, 작업을 `master`로 병합할 수 있다.
- 병합된 후 `master` 브랜치로 푸시되면, 즉시 배포할 수 있게 된다.

<br><br>

## GitHub flow 알아 보기

![github flow (1)](https://user-images.githubusercontent.com/47686322/88545176-93e0c400-d055-11ea-8487-0184d6ecde65.png)

GitHub에서 소개하고 있는 GitHub flow에 대하여 알아 보자.

### 1. Branch 생성하기

프로젝트를 진행할 때에는 특정 시점에 진행 중인 각기 다른 기능이나 아이디어가 있을 것이다. 이 중 어느 것은 준비가 완료되고, 또 다른 어느 것은 아직 준비가 되지 않았을 수도 있다. 이러한 상황에서 브랜치는 해당 워크플로우를 관리하는 데 도움을 줄 수 있다.

무엇이든 새로운 작업을 시작하려면 이러한 안정적인 `master` 브랜치로부터 새로운 브랜치를 생성하게 된다. 이전 목차에서도 언급하였듯 `master` 브랜치는 항상 바로 배포가 되어도 문제가 없도록 안전한 코드를 가지고 있어야 한다.

브랜치를 생성하기 위해선 이름을 지정해야 한다. 이러한 브랜치명은 설명적인 이름을 지정하도록 한다. 다음과 같은 브랜치 이름의 몇 가지 예시가 존재한다:

- `refactor-authentication`
- `user-content-cache-key`
- `make-retina-avatars`

프로젝트에서 브랜치를 생성하였다면, 새로운 아이디어를 시도해 볼 수 있는 환경이 생성된 것과도 같다. 해당 브랜치에 어떠한 변경 사항이 발생하더라도 `master` 브랜치에는 영향을 미치지 않는다. 만약 공동으로 작업중인 누군가가 있다면, 이들이 검토할 준비가 될 때 까지 새롭게 만든 브랜치는 병합되지 않는다는 사실을 알고 마음껏 변경 내용을 실험하고 커밋할 수 있게 된다.

<br>

### 2. Commit 추가하기

브랜치를 생성하였다면, 다음으로는 변경 사항을 만들어야 한다. 파일을 추가, 수정 혹은 삭제할 때마다 이러한 사항을 커밋하고 브랜치에 추가해야 한다. 이러한 과정은 `feature` 브랜치에서 작업의 진행 상황을 추적하도록 한다.

또한 커밋은 자신이 수행한 작업과 그 이유를 다른 작업자가 이해하도록 하기 위해 따를 수 있는 투명한 작업 기록을 만든다. 각각의 커밋에는 관련된 커밋 메시지가 존재하며, 이는 특정 변경이 이루어진 이유를 설명한다. 또 각 커밋은 별도의 변경 단위로 간주된다. 이를 통해 버그가 발견되거나 다른 방향으로 향하기로 결정한 경우 변경 사항을 롤백할 수 있다.

커밋을 할 때 남기는 커밋 메시지는 Git이 변경 사항을 추적한 다음 서버에 푸시되면 커밋으로 표시하기 때문에 중요하다. 커밋 메시지를 명확하게 작성해야 다른 사람들이 쉽게 따라하고 피드백을 제공하도록 할 수 있다.

<br>

### 3. Pull Request 열기

풀 리퀘스트는 커밋에 대한 토론을 시작한다. 기초적인 Git 저장소와 밀접하게 통합되어 있기 때문에, 누구나 요청을 수락하면 어떤 변경 사항이 병합되는 지 정확히 볼 수 있다.

개발 진행 중 언제라도 풀 리퀘스트를 열 수 있다. 코드가 있지 않더라도 일부 스크린샷이나 일반적인 아이디어를 공유하고 싶을 때, 도움이나 조언이 필요할 때, 혹은 자신의 작업을 누군가가 검토하도록 할 준비가 되었을 때 등등.

풀 리퀘스트 메시지에 GitHub의 `@mention` 시스템을 이용하면 특정 인원이나 팀에게 피드백을 요청할 수 있다.

풀 리퀘스트는 오픈 소스 프로젝트에 기여하고 공유 리포지토리의 변경 사항을 관리하는 데에도 유용하다.

- Fork & Pull 모델을 사용하는 경우, 풀 리퀘스트는 프로젝트 관리자에게 고려해 볼 변경 사항을 알리는 방법을 제시한다.
- 공유 리포지토리 모델을 사용하는 경우, 풀 리퀘스트는 제안 된 변경 사항이 `master` 브랜치로 병합되기 전에 변경 사항에 대한 코드 검토 및 대화를 시작할 수 있다.

<br>

### 4. 코드에 대해 토론하고 검토하기

풀 리퀘스트가 열리면 해당 변경 사항을 검토하는 사람이나 팀에서 질문이나 의견이 발생할 수 있다. 풀 리퀘스트는 다음과 같은 경우에 대화를 장려하고 포착할 수 있도록 설계되었다.

- 코딩 스타일이 프로젝트 가이드라인에 어긋남
- 변경 사항에 유닛 테스트가 누락됨
- 모든 것이 멋지게 보이고 props가 순서대로 표시됨

<br>

### 5. Deploy

GitHub를 사용하면 `master` 브랜치로 병합하기 전에 프로덕션에서 최종 테스트를 위한 브랜치로부터 배포할 수 있다.

풀 리퀘스트가 검토되고 브랜치가 테스트를 통과하면 변경 사항을 배포하여 프로덕션 환경에서 확인할 수 있다. 만약 브랜치에서 문제 발생 시 기존의 `master` 브랜치를 프로덕션에 배포하여 브랜치를 롤백시킬 수 있다.

배포 전략은 팀마다 다를 수도 있다.

<br>

### 6. Merge

프로덕션 환경에서 변경 사항이 확인되었으므로 이제 코드를 `master` 브랜치로 병합해야 한다.

풀 리퀘스트는 병합되면 코드에 대한 변경 기록을 유지한다. 검색이 가능하기 때문에 누구든 과거에 내려진 결정이 왜 이루어 졌는지, 어떻게 이루어 졌는지 이해할 수 있다.

<br><br>

## 마치며

널리 알려져 있는 여러 Git 운영 전략들이 저장소 관리에 있어 절대적인 지침이며 이를 따라야만 하는 것은 아니다. 하지만 다수의 사람들이 이들 모델들을 유용하다 여겨 채택하여 사용하고 있는 것은 사실이다. 여러 포스팅을 읽고 생각해보니 다른 사람들과 함께 개발을 한다면 좋은 코드를 작성하는 것도 중요하지만 '왜 이렇게 짰고 어떻게 받아들여졌는지' 라는 사항들도 못지 않게 중요한 것 같다. 또한 지금까지 많은 프로젝트에서 `master`, `develop` 브랜치만을 이용해 단순히 코드 백업&병합의 용도로만 사용해왔던 지난 날들을 반성해보게 된다. 🙄 개인/소규모 프로젝트가 아닌 중/대규모 프로젝트라면 이러한 효율적인 Git 관리 방식의 필요성이 중대해질 것 같다. 앞으로의 프로젝트에서는 상황에 맞도록 적용시켜 봐야겠다.

이번 포스팅에선 GitHub-flow에 대해서만 알아보았는데, 만약 장기간 간격으로 정식적인 릴리스를 수행해야 하거나 프로덕션 환경에서 여러 버전을 제공해야 하는 경우 등이 있다면 git-flow 전략을 고려해 보는 것이 좋을 것이다. 다음 포스팅에서는 이러한 git-flow에 대해서도 알아보고자 한다.

<br><br>

## 참조

[Understanding the GitHub flow](https://guides.github.com/introduction/flow/){:target="\_blank"}\\
[GitHub flow](http://scottchacon.com/2011/08/31/github-flow.html){:target="\_blank"}\\
[GitHub flow Workflow](http://www.clinicalgenomics.se/development/dev/githubflow/){:target="\_blank"}
